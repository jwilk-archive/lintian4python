#!/usr/bin/python3

# refresh-sys.path-additions -- Refresh Lintian data about sys.path additions
#
# Copyright Â© 2012 Jakub Wilk
#
# This program is free software.  It is distributed under the terms of the GNU
# General Public License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along with
# this program.  If not, you can find it on the World Wide Web at
# http://www.gnu.org/copyleft/gpl.html, or write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.

import collections
import contextlib
import datetime
import os
import re
import shutil
import subprocess as ipc
import tempfile

import apt
import apt_inst
import apt_pkg

header = '''\
# This file contains list of {python} packages that add extra entries to
# sys.path via .pth files.
# It was automatically generated by private/refresh-sys.path-additions.
#
# Last update: {today}

'''

pth_regex = re.compile(br'''
(?: (
    usr/lib/pyshared/python2\.\d+ | # python-support >= 0.90
    usr/share/pyshared | # python-support >= 0.90, python-central, dh_python2
    usr/lib/python-support/[^/]+/python2\.\d+ | # python-support < 0.90
    usr/share/python-support/[^/]+ | # python-support < 0.90
    usr/lib/python2\.\d+/(?:site|dist)-packages # python-central, dh_python2
) | (
    usr/lib/python3/dist-packages
)) /
([^/\s]+\.pth)
\s+
(\S+)
''', re.VERBOSE)

pymodules_regex = re.compile('^/usr/lib/pymodules/python2\.[0-9]+/')

@contextlib.contextmanager
def zcat(filename):
    with open(filename, 'rb') as stdin:
        child = ipc.Popen(['gzip', '-dc'], stdin=stdin, stdout=ipc.PIPE)
        yield child.stdout
    if child.wait() != 0:
        raise IOError

def run_fetcher(fetcher):
    rc = fetcher.run()
    if rc != fetcher.RESULT_CONTINUE:
        raise RuntimeError('fetching files failed')
    for file in fetcher.items:
        if file.status != file.STAT_DONE:
            raise RuntimeError('fetching file failed: {uri}'.format(uri=file.desc_uri))

def main():
    architecture = 'i386'
    lintian_root = os.getenv('LINTIAN_ROOT') or '.'
    mirror = os.getenv('DEB_MIRROR') or 'http://http.debian.net/debian'
    tmpdir = tempfile.mkdtemp(prefix='lintian4python.private.')
    progress = apt.progress.text.AcquireProgress()
    fetcher = apt_pkg.Acquire(progress)
    uri = '{mirror}/dists/unstable/main/Contents-{arch}.gz'.format(mirror=mirror, arch=architecture)
    contents_filename = uri.split('/')[-1]
    contents_file = apt_pkg.AcquireFile(fetcher,
        uri=uri,
        descr='Contents-{arch}'.format(arch=architecture),
        destfile=os.path.join(tmpdir, contents_filename)
    )
    uri = '{mirror}/dists/unstable/main/binary-i386/Packages.gz'.format(mirror=mirror, arch=architecture)
    packages_filename = uri.split('/')[-1]
    packages_file = apt_pkg.AcquireFile(fetcher,
        uri=uri,
        descr='Packages-{arch}'.format(arch=architecture),
        destfile=os.path.join(tmpdir, packages_filename)
    )
    run_fetcher(fetcher)
    contents_path = os.path.join(tmpdir, contents_filename)
    with zcat(contents_path) as file:
        contents = file.read()
    os.unlink(contents_path)
    del contents_file, contents_path
    contents = contents.splitlines()
    path_info = {
        2: collections.defaultdict(set),
        3: collections.defaultdict(set),
    }
    for line in contents:
        match = pth_regex.match(line)
        if match:
            py2dir, py3dir, pth, packages = match.groups()
            version = 2 + bool(py3dir)
            pth = os.path.join((py2dir or py3dir), pth).decode('ASCII')
            packages = [pkg.split('/')[-1] for pkg in packages.decode('ASCII').split(',')]
            for package in packages:
                path_info[version][package].add(pth)
    packages = set()
    for subpath_info in path_info.values():
        packages.update(subpath_info.keys())
    debs = {}
    packages_path = os.path.join(tmpdir, packages_filename)
    with zcat(packages_path) as file:
        for para in apt_pkg.TagFile(file):
            try:
                pkgname = para['package']
                packages.remove(pkgname)
            except KeyError:
                continue
            path = para['filename']
            base = os.path.basename(path)
            debs[pkgname] = apt_pkg.AcquireFile(fetcher,
                uri='{mirror}/{path}'.format(mirror=mirror, path=path),
                descr=base,
                destfile=os.path.join(tmpdir, base),
            )
    os.unlink(packages_path)
    del packages_file, packages_path
    run_fetcher(fetcher)
    results = {
        2: collections.defaultdict(set),
        3: collections.defaultdict(set),
    }
    for pkgname, file in debs.items():
        tar = apt_inst.DebFile(file.destfile).data
        for version in 2, 3:
            try:
                paths = path_info[version][pkgname]
            except LookupError:
                continue
            for path in paths:
                pth_contents = tar.extractdata(path)
                for pth_item in pth_contents.splitlines():
                    if pth_item.startswith((b'import ', b'import\t', b'#')):
                        continue
                    pth_item = pth_item.decode('ASCII').rstrip('/')
                    pth_item = pymodules_regex.sub('', pth_item)
                    pth_item = re.sub('//+', '/', pth_item)
                    results[version][pth_item].add(pkgname)
    pygtk2_additions = results[2]['gtk-2.0']
    assert pygtk2_additions == {'python-gobject-2'}
    pygtk2_additions.add('python-gtk2')
    for version in 2, 3:
        path = '{root}/data/python/sys.path-additions'.format(root=lintian_root)
        if version == 3:
            path += '-py3k'
        with open(path, 'wt', encoding='ASCII') as file:
            file.write(header.format(
                python='Python {n}.X'.format(n=version),
                today=datetime.date.today(),
            ))
            for item, packages in sorted(results[version].items()):
                print('{item} => {packages}'.format(
                    item=item,
                    packages=' | '.join(sorted(packages))
                ), file=file)
    shutil.rmtree(tmpdir)

if __name__ == '__main__':
    main()

# Local Variables:
# indent-tabs-mode: nil
# End:
# vim: syntax=python sw=4 sts=4 sr et
